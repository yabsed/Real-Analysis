Based on the provided exam paper and lecture materials, here is a comprehensive, self-contained study guide. It focuses on the technical mechanisms, algorithmic logic, and "code-level" details required for the exam.

-----

### **I. Concurrency & Synchronization Algorithms**

#### **1. Race Conditions & Critical Sections**

  * **Race Condition:** Occurs when multiple threads enter a critical section at roughly the same time and attempt to update a shared data structure, leading to surprising/incorrect outcomes.
  * **Stack Allocation:** Variables allocated on the stack (local variables, return addresses) are in **thread-local** storage. They are *not* shared between threads.
  * **Shared State:** In a POSIX multithreaded process, threads share:
      * Heap memory
      * Global variables
      * Code memory
      * Open file descriptors
      * Process ID (PID)
      * *Threads do NOT share:* Registers, Stack memory.

#### **2. Locking Mechanisms**

  * **Spin Locks:** The simplest lock. A thread "spins" (burns CPU cycles) in a loop checking if the lock is available.
      * **Requirement:** On a single processor, a spin lock requires a **preemptive scheduler**. Without preemption, the spinning thread would hold the CPU forever, never allowing the lock holder to run and release the lock.

#### **3. The Bakery Algorithm (Software Mutual Exclusion)**

Used to ensure mutual exclusion without hardware atomic instructions. Threads "take a number"; the lowest number enters the critical section first.

  * **Data Structures:**
      * `choosing[N]`: Boolean, indicates a thread is currently calculating its number.
      * `number[N]`: Integer, the ticket number (0 means not interested).
  * **The Logic:**
    1.  **Doorway:** Thread sets `choosing[me] = true`. Calculates `number[me] = max(number[0]...number[N-1]) + 1`. Sets `choosing[me] = false`.
    2.  **Waiting:** Thread iterates through all other threads (`j`).
          * Wait while `choosing[j]` is true.
          * Wait while `number[j] != 0` AND (`number[j], j` is smaller than `number[me], me`).
  * **Critical Questions:**
      * **Starvation:** Cannot occur. The algorithm is First-Come-First-Served (FCFS) based on ticket numbers.
      * **Role of `choosing`:** Essential. If removed, a race condition occurs. Thread A could calculate a number (e.g., 5) but not yet write it. Thread B reads max=4, writes 5. Now both have 5. Without `choosing` acting as a lock for the number assignment, the lexicographical check fails to protect the critical section correctly in all timing windows.
      * **Optimization with `fetch_and_add`:**
          * If hardware supports atomic `fetch_and_add`, the `choosing` array is unnecessary because the ticket assignment becomes atomic.
          * *Code:* `number[me] = fetch_and_add(&global_ticket, 1);`

#### **4. Barrier Synchronization**

A barrier blocks threads until *N* threads have reached that point.

  * **Implementation with Semaphores:**
      * Requires two semaphores and a counter.
      * `mutex` (init 1): Protects the counter.
      * `barrier` (init 0): Block threads.
      * *Logic:*
        ```c
        wait(mutex);
        count++;
        if (count == N) {
            signal(barrier); // Wake one, which chains the next
        }
        signal(mutex);
        wait(barrier);
        signal(barrier); // "Turnstile": passing thread wakes the next
        ```
  * **Implementation with Mutex & Condition Variables (Mesa Semantics):**
      * *Logic:*
        ```c
        mutex_lock(&m);
        count++;
        if (count == N) {
            cond_broadcast(&c); // Wake EVERYONE
            count = 0;          // Reset for next phase (optional)
        } else {
            while (count < N) {
                cond_wait(&c, &m);
            }
        }
        mutex_unlock(&m);
        ```
      * *Note:* Using `broadcast` is efficient here. Using `signal` would require a chain reaction strategy.

-----

### **II. System Architecture & Operation Costs**

#### **1. Operation Cost Hierarchy (Cheapest to Most Expensive)**

1.  **Branch/Jump:** CPU internal instruction. Changes PC.
2.  **Procedure Call:** Saves return address/registers to stack. Changes PC.
3.  **User-level Thread Switch:** Save/restore user registers. No kernel involvement.
4.  **Kernel-level Thread Switch:** Requires mode switch (User $\to$ Kernel), saving kernel state, scheduler invocation, TLB flush implications.

#### **2. I/O Architecture**

  * **Simplified Interface Registers:**
      * **Status:** Read to see current device state (busy/ready).
      * **Command:** Write to tell device to perform a task.
      * **Data:** Pass data to/from device.
  * **DMA (Direct Memory Access):** When the main CPU is *not* involved in the data movement. A specialized engine copies data between device and memory.
  * **HDD Mechanics:**
      * **Spindle Motor:** Spins platters at constant rate.
      * **Track Buffer (Cache):** Small memory on disk to hold data read/written.
  * **SSD Reliability:**
      * **Read Disturb:** Accessing a page frequently can cause bit flips in *neighboring* pages within the same block.

-----

### **III. File System Implementation (VSFS Concept)**

#### **1. On-Disk Layout (VSFS)**

The disk is divided into fixed-size blocks (e.g., 4KB).

1.  **Superblock:** Contains FS metadata (magic number, total blocks, inode count).
2.  **Bitmaps:**
      * **Inode Bitmap:** Tracks free/allocated inodes.
      * **Data Bitmap:** Tracks free/allocated data blocks.
3.  **Inode Table:** Array of Inodes.
4.  **Data Region:** The largest portion, stores user file content and directory data.

#### **2. The Inode (Index Node)**

  * **Definition:** The generic structure holding *metadata* for a specific file.
  * **Contents:** Size, UID, GID, permissions (mode), timestamps (access, modify, create), and **block pointers**.
  * **Mapping to Disk:**
      * `Inode Block = (Inode Number * Inode Size) / Block Size`
  * **Multi-Level Indexing (Pointers):**
      * **Direct Pointers:** Point directly to data blocks (e.g., 12 pointers).
      * **Indirect Pointer:** Points to a block full of pointers.
      * **Double Indirect:** Points to a block of indirect pointers.
      * *Calculation:* If Block Size = 4KB and Pointer = 4 bytes (1024 pointers per block):
          * Max size with direct only: $12 \times 4$KB.
          * Max size adding single indirect: $+(1024 \times 4$KB).
          * Max size adding double indirect: $+(1024^2 \times 4$KB).

#### **3. Directory Organization**

  * **Concept:** A directory is a special file. Its "data" is a list of entries.
  * **Entry Structure:** `(name, inode_number)`.
  * **Operations:**
      * Finding a file `/foo/bar` requires traversing the tree.
      * **Root Inode** is usually fixed (e.g., Inode 2).

#### **4. Access Paths (The "Trace")**

Understanding the exact I/O for `open("/foo/bar", O_RDONLY)`:

1.  **Read Root Inode:** Get location of Root data.
2.  **Read Root Data:** Look for "foo". Find Inode number for "foo".
3.  **Read Foo Inode:** Get location of Foo data.
4.  **Read Foo Data:** Look for "bar". Find Inode number for "bar".
5.  **Read Bar Inode:** Load metadata into memory.
6.  *Result:* File descriptor returned.

<!-- end list -->

  * **Write Cost:** Creating a file is expensive.
      * Read Inode Bitmap (find free).
      * Write Inode Bitmap (mark allocated).
      * Write new Inode (init metadata).
      * Read Parent Directory Data (to insert name).
      * Write Parent Directory Data (link name to inode).
      * Update Parent Directory Inode (timestamps/size).

#### **5. Caching & Buffering**

  * **Read Cache:** Uses system memory (Unified Page Cache) to cache blocks. Second access to same file avoids I/O.
  * **Write Buffering:** Delays writes (5-30 seconds).
      * *Pros:* Performance, batching updates (overwriting same block), avoiding writes for temporary files.
      * *Cons:* Data loss on crash (durability trade-off).
      * **fsync():** Forces dirty data to disk immediately.

-----

### **IV. Advanced File System Topics (Exam Specials)**

#### **1. FAT (File Allocation Table)**

  * **Linked Allocation Variation:** Instead of pointers *inside* the data block, pointers are kept in a separate table (FAT) at the beginning of the disk.
  * **Structure:** An array indexed by block number. Entry `FAT[i]` contains the index of the next block.
  * **Directory Entry (FATty system):**
      * Unlike Unix, FAT directory entries often contain the metadata (Name, Size, First Block \#). There are no formal Inodes.
  * **Math Check:**
      * If Block = 4KB, FAT Entry = 3 bytes (24-bit).
      * Disk Size = 4GB. Total Blocks = $4GB / 4KB = 1M$ blocks.
      * FAT Size = $1M \text{ entries} \times 3 \text{ bytes} = 3MB$.
      * Blocks needed for FAT = $3MB / 4KB$.

#### **2. Fast File System (FFS) Optimization**

  * **Rotational Delay:** Old FFS layout skipped blocks (e.g., write to block 1, then 3, then 5) to account for disk rotation speed during sequential writes. This is called **Block Interleaving**.

#### **3. Full Path Indexing**

A proposed optimization where the file system maintains a single massive map: `Full Path String -> Inode Number`.

  * **Lookup:** $O(1)$ hash map lookup instead of $O(depth)$ recursive directory traversal.
  * **Advantages:** extremely fast `open()` for deep paths.
  * **Disadvantages/Drawbacks:**
      * **Hard Links:** Very difficult. A file has one inode but multiple paths. The index maps Path $\to$ Inode. If you link `/a/b` to `/c/d`, the index needs two entries.
      * **Rename/Move:** Moving a directory `/user/old` to `/user/new` requires updating the index keys for *every* file under that directory (modifying thousands of string prefixes). Standard FS only updates one directory entry.
      * **Space:** Storing full path strings is redundant and consumes huge space compared to hierarchical names (where "bin" is stored once, not repeated in `/usr/bin/ls`, `/usr/bin/vim`, etc.).

#### **4. Symbolic Links (Symlinks)**

  * **Standard FS:** A file containing a path string.
  * **In Full Path Indexing:** The index entry for the symlink points to a special inode containing the target path. The OS reads this path and restarts the lookup in the index.