Based on the provided textbook chapter (OSTEP Ch 39), lecture slides, and the specific style of the final exam (which emphasizes concurrency logic, API mechanics, and file system layout calculations), here is a comprehensive, self-contained study guide.

-----

# Comprehensive Operating Systems Study Guide: File Systems & Concurrency

## Part 1: File System Abstractions & Architecture

### 1.1 The Storage Stack Hierarchy

  * **User-level:** Standard Libraries (`stdio.h`, `printf`, `fopen`).
  * **POSIX API:** System calls (`open`, `read`, `write`, `close`).
  * **VFS (Virtual File System):** A uniform interface allowing different FS types (Ext4, XFS, NTFS) to coexist.
  * **Generic Block Layer:** Handles block I/O scheduling.
  * **Device Driver:** Protocol-specific control (NVMe, SATA).
  * **Hardware:** HDD (sectors, tracks, platters) or SSD (pages, blocks).

### 1.2 Core Abstractions

1.  **The File:**

      * **View:** Linear array of bytes.
      * **Low-level name:** **Inode Number (i-number)**. Uniquely identifies the file within a partition.
      * **OS Responsibility:** Map logical offset (file byte $X$) to physical block (disk sector $Y$).
      * **Persistence:** Unlike RAM, data survives power loss.

2.  **The Directory:**

      * **Definition:** A specific type of file containing a list of `(user_readable_name, inode_number)` pairs.
      * **Structure:** Hierarchy/Tree starting at Root (`/`).
      * **Standard Entries:**
          * `.` (current directory).
          * `..` (parent directory).

### 1.3 Inodes & Metadata

  * **Metadata:** Information *about* the file, stored in the **Inode**.
  * **Content:**
      * Size (bytes).
      * Low-level name (i-number).
      * Permissions (rwx).
      * Owner/Group IDs.
      * Timestamps (`atime`: access, `mtime`: modify, `ctime`: inode change).
      * Block count & location pointers.
  * **Note:** The *name* of the file is stored in the **directory**, not the inode.

-----

## Part 2: File System APIs & Implementation Mechanisms

### 2.1 Creating and Opening Files

  * **`open(path, flags, mode)`**: Returns a **File Descriptor (fd)**.
      * `O_CREAT`: Create file if it doesn't exist.
      * `O_WRONLY`: Open for writing only.
      * `O_TRUNC`: Truncate size to 0 (delete existing content).
  * **`creat()`**: Legacy call. Equivalent to `open` with specific flags.

### 2.2 File Descriptors (FD)

  * **Definition:** An integer handle private to a process.
  * **Standard FDs:**
      * `0`: Standard Input (stdin).
      * `1`: Standard Output (stdout).
      * `2`: Standard Error (stderr).
  * **Allocation:** OS usually assigns the *lowest available* integer (e.g., first manual open gets 3).

### 2.3 The Open File Table (Critical Architecture Concept)

  * **Per-Process Structure:** `struct proc` contains an array of file descriptors `ofile[NOFILE]`.
  * **System-Wide Structure:** **Open File Table (OFT)**.
  * **FD Pointers:** `fd` (integer) $\to$ pointer to `struct file` (in OFT).
  * **`struct file` Contents:**
      * **Current Offset:** Tracks where the next read/write happens.
      * **Reference Count:** How many FDs point to this entry.
      * **Inode Pointer:** Points to the actual file on disk.
      * **Mode:** Readable/Writable status.

### 2.4 Sequential vs. Random Access (`lseek`)

  * **Sequential:** `read()`/`write()` implicitly update the **current offset**.
  * **Random Access:** `lseek(fd, offset, whence)` explicitly changes the offset.
      * `SEEK_SET`: Set offset to $X$.
      * `SEEK_CUR`: Current offset + $X$.
      * `SEEK_END`: File size + $X$.
  * **Important:** `lseek` modifies a variable in OS memory (OFT). It does **not** trigger disk I/O (disk head movement) until the next read/write occurs.

### 2.5 Shared File Entries (Fork vs. Dup)

  * **Case A: `fork()`**

      * Child inherits a *copy* of the parent's FD table.
      * **Result:** Parent and Child FDs point to the **same** Open File Table entry.
      * **Implication:** They **share the current offset**. If Parent reads 10 bytes, Child's next read starts at offset 10.
      * **Ref Count:** Incremented in OFT.

  * **Case B: `dup(fd)` / `dup2()`**

      * Creates a new FD that points to the **same** OFT entry as the old FD.
      * **Implication:** Interchangable FDs, shared offset. Used for I/O redirection (e.g., shell replacing stdout with a file).

  * **Case C: Distinct Opens**

      * Process calls `open("file")` twice.
      * **Result:** Two distinct entries in OFT.
      * **Implication:** Independent offsets.

### 2.6 Persistence (`fsync`)

  * **Buffering:** `write()` usually updates the "Page Cache" in RAM for performance (delayed write).
  * **Risk:** Crash before flush = data loss.
  * **`fsync(fd)`**: Forces dirty data *and* metadata to disk immediately.
  * **`fdatasync(fd)`**: flushes data but avoids non-essential metadata updates (optimization).
  * **Correctness:** To guarantee a new file is persistent, you must `fsync` the file **AND** `fsync` the parent directory.

-----

## Part 3: Directory Operations & Links

### 3.1 Directory APIs

  * **`mkdir()`**: Creates empty directory (contains `.` and `..`).
  * **`rmdir()`**: Removes directory (must be empty).
  * **`opendir()`, `readdir()`, `closedir()`**: Iterates entries.
      * `readdir` returns `struct dirent` (name, inode number).
      * Does *not* return file contents, just the listing.

### 3.2 Hard Links (`link`)

  * **Command:** `ln old new` or `link(old, new)`.
  * **Mechanism:** Creates a new directory entry (name) pointing to the **same inode number**.
  * **Inode State:** `link_count` increments.
  * **Deletion:** `unlink(name)` removes the directory entry and decrements `link_count`.
  * **Freeing:** Inode/Blocks are freed only when `link_count == 0`.
  * **Limitations:** Cannot link directories (prevents cycles). Cannot link across partitions.

### 3.3 Symbolic (Soft) Links (`symlink`)

  * **Command:** `ln -s old new`.
  * **Mechanism:** Creates a **new file** (new inode, different type).
  * **Content:** The data of this file is the **path** to the target file.
  * **Behavior:**
      * If target is deleted: Link becomes "dangling" (points to nothing).
      * Can link directories and cross partitions.
  * **Size:** Size of symlink = length of the path string (e.g., "file" $\to$ 4 bytes).

### 3.4 Renaming (`rename`)

  * **Atomicity:** `rename(old, new)` is atomic.
  * **Usage:** Critical for consistent updates.
    1.  Write to `temp_file`.
    2.  `fsync(temp_file)`.
    3.  `rename(temp_file, target_file)`.
    <!-- end list -->
      * Ensures `target_file` is never in a partial/corrupted state.

-----

## Part 4: Exam-Specific Concepts (Concurrency & Problems)

Based on the provided Final Exam, these areas require code-level understanding.

### 4.1 Race Conditions & Synchronization

  * **Race Condition:** Output depends on timing/ordering of threads.
  * **Starvation:** A thread waits indefinitely while others proceed.
  * **Deadlock:** Circular wait where no thread proceeds.

### 4.2 The Bakery Algorithm (Software Mutual Exclusion)

  * **Concept:** Like taking a number at a deli.
  * **Variables:**
      * `choosing[i]`: Thread $i$ is currently taking a number.
      * `number[i]`: The number thread $i$ holds (0 = not interested).
  * **Logic (Acquire Lock):**
    1.  Set `choosing` true.
    2.  `number[i] = max(all_numbers) + 1`.
    3.  Set `choosing` false.
    4.  **Wait Loop:** Wait for threads with lower numbers (higher priority) or same number but lower ID.
  * **Key Exam Insight (Starvation):** Bakery algorithm is **starvation-free** (FCFS fairness).
  * **Optimization:** Can be simplified with hardware atomic instructions like `fetch_and_add`.

### 4.3 Barriers (Coordination)

  * **Goal:** $N$ threads must all reach a point before *any* proceed.
  * **Implementation 1: Semaphores**
      * Need to track count of arrived threads.
      * Last thread triggers a "turnstile" or signals others.
      * *Exam Pattern:* Using an array of semaphores or a mutex + counting semaphore.
  * **Implementation 2: Mutex & Condition Variables (Mesa Semantics)**
      * `mutex_lock`; `count++`;
      * If `count < N`: `cond_wait`.
      * Else (`count == N`): `cond_broadcast` (wake everyone), reset count.
      * `mutex_unlock`.

### 4.4 File System Layout Calculations (FATty/Inode)

  * **FAT (File Allocation Table):**
      * Linked list of blocks stored in a table.
      * Table Entry Size: e.g., 24 bits (3 bytes) or 32 bits.
      * **Calculation:** Total Blocks = Disk Size / Block Size.
      * **FAT Size:** Total Blocks $\times$ Entry Size.
  * **Inode Traversal Cost:**
      * Path: `/usr/bin/ls`
      * **Steps:**
        1.  Read Root Inode.
        2.  Read Root Data (lookup "usr").
        3.  Read "usr" Inode.
        4.  Read "usr" Data (lookup "bin").
        5.  Read "bin" Inode.
        6.  Read "bin" Data (lookup "ls").
        7.  Read "ls" Inode.
      * **Exam Q:** Count block reads. Be careful to distinguish "Inode blocks" from "Directory Data blocks".

### 4.5 Full Path Indexing (Optimization)

  * **Concept:** Map `"/usr/bin/ls"` directly to `Inode #10`.
  * **Data Structure:** Hash Map or B-Tree stored in a special file/superblock.
  * **Time Complexity:**
      * Standard: $O(d \times n)$ where $d$=depth, $n$=entries per dir.
      * Full Path: $O(1)$ (hashing) or $O(\log N)$ (tree).
  * **Trade-offs:**
      * **Pros:** Fast lookups, no directory traversal.
      * **Cons:**
          * **Rename cost:** Renaming a directory requires updating all children paths in index.
          * **Hard Links:** Difficult to map multiple paths to one inode efficiently.
          * **Space:** Path strings consume significant space compared to hierarchy.

-----

## Part 5: Code & Mechanics Cheatsheet

### File Descriptor Inheritance

```c
int fd = open("file", O_RDONLY); // fd = 3
if (fork() == 0) {
    // Child: fd 3 exists here too.
    // Reading fd 3 moves the SAME offset parent sees.
}
```

### Dup Usage (Redirection)

```c
int fd = open("out.txt", ...);
close(1);      // Close stdout
dup(fd);       // Copy fd to lowest slot (1)
// Now printf goes to out.txt
```

### Barrier with Cond Vars (Code Pattern)

```c
mutex_lock(&m);
arrived++;
if (arrived < N) {
    cond_wait(&c, &m);
} else {
    cond_broadcast(&c); // Wake all
    arrived = 0;        // Reset for next phase (if reusable)
}
mutex_unlock(&m);
```

### TOCTTOU (Security)

  * **Time Of Check To Time Of Use:** A vulnerability.
  * *Example:* Check if file is safe $\to$ Attacker changes file to symlink to `/etc/passwd` $\to$ Program writes to file.
  * *Fix:* Atomicity or using file descriptors instead of paths after check.

### Important "Gotchas" for Exam

1.  **Reading a directory:** You cannot `write()` to a directory directly. You use `creat/link/unlink`. You *can* `read()` it (via `readdir`), but it returns metadata structures, not file content.
2.  **`lseek` vs Disk Seek:** `lseek` is an O(1) memory update. Disk seek is slow mechanical movement (milliseconds).
3.  **Inode Numbers:** Unique per filesystem/partition. Not unique across the whole computer if multiple drives are mounted.
4.  **`rm file`:** Does not delete data immediately. It calls `unlink`. Data deleted only when `ref_count == 0` AND file is closed by all processes.